name: 'Pack Dependency'
description: 'Downloads, builds, and packs a dependency from a source repository'
inputs:
  repository:
    description: 'Source repository (owner/name)'
    required: true
  target-sha:
    description: 'Target commit SHA or branch name'
    required: false
    default: ''
  package-name:
    description: 'Name of the package in package.json'
    required: false
  pack-destination:
    description: 'Directory where packed files will be placed'
    required: false
    default: './packs'
  package-command:
    description: 'Build/package command to run before packing'
    required: false
  pack-command:
    description: 'Custom pack command (overrides default pnpm pack)'
    required: false
  file-path:
    description: 'Path to version file (.ui-sha, .registry-sha, etc)'
    required: false
    default: '.ui-sha'
  token:
    description: 'GitHub token for accessing the repository'
    required: true
outputs:
  short-sha:
    description: 'Short SHA of the packed commit'
    value: ${{ steps.pack.outputs.short-sha }}
  full-sha:
    description: 'Full SHA of the packed commit'
    value: ${{ steps.pack.outputs.full-sha }}
  package-file:
    description: 'Path to the created package file'
    value: ${{ steps.pack.outputs.package-file }}
  last-sha:
    description: 'SHA from the version file'
    value: ${{ steps.pack.outputs.last-sha }}
  changelog:
    description: 'Commit changelog between versions'
    value: ${{ steps.pack.outputs.changelog }}

runs:
  using: 'composite'
  steps:
    - name: Build and Pack Dependency
      id: pack
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        set -e
        
        # Input variables
        REPOSITORY="${{ inputs.repository }}"
        TARGET_SHA="${{ inputs.target-sha }}"
        PACKAGE_NAME="${{ inputs.package-name }}"
        PACK_DESTINATION="${{ inputs.pack-destination }}"
        PACKAGE_COMMAND="${{ inputs.package-command }}"
        PACK_COMMAND="${{ inputs.pack-command }}"
        FILE_PATH="${{ inputs.file-path }}"
        TOKEN="${{ inputs.token }}"
        
        echo "Repository: $REPOSITORY"
        echo "Target SHA: $TARGET_SHA"
        echo "Package name: $PACKAGE_NAME"
        echo "Pack destination: $PACK_DESTINATION"
        echo "File path: $FILE_PATH"
        
        # Read last SHA from file
        LAST_SHA=""
        if [ -f "$FILE_PATH" ]; then
          # Extract SHA from file (handle both plain SHA and comment formats)
          LAST_SHA=$(grep -v '^#' "$FILE_PATH" | grep -E '^[a-f0-9]{40}$' | head -1 || echo "")
          echo "Last SHA from $FILE_PATH: $LAST_SHA"
        else
          echo "No existing $FILE_PATH found"
        fi
        
        # Save outputs
        echo "last-sha=$LAST_SHA" >> $GITHUB_OUTPUT
        
        # Create temp directory for cloning
        TEMP_DIR=$(mktemp -d)
        echo "Using temp directory: $TEMP_DIR"
        
        # Clone the repository
        echo "Cloning $REPOSITORY..."
        cd "$TEMP_DIR"
        
        # Clone with token auth
        git clone "https://x-access-token:${TOKEN}@github.com/${REPOSITORY}.git" repo
        cd repo
        
        # Get default branch if not specified
        if [ -z "$TARGET_SHA" ]; then
          echo "No target SHA specified, fetching default branch..."
          DEFAULT_BRANCH=$(gh api "repos/${REPOSITORY}" --jq '.default_branch')
          echo "Using default branch: $DEFAULT_BRANCH"
          TARGET_SHA="$DEFAULT_BRANCH"
        fi
        
        # Checkout target
        echo "Checking out $TARGET_SHA..."
        git checkout "$TARGET_SHA"
        
        # Get the actual SHA
        FULL_SHA=$(git rev-parse HEAD)
        SHORT_SHA=$(git rev-parse --short HEAD)
        echo "Checked out SHA: $FULL_SHA (short: $SHORT_SHA)"
        
        # Save SHA outputs
        echo "full-sha=$FULL_SHA" >> $GITHUB_OUTPUT
        echo "short-sha=$SHORT_SHA" >> $GITHUB_OUTPUT
        
        # Generate changelog if we have a previous SHA
        CHANGELOG=""
        if [ -n "$LAST_SHA" ]; then
          echo "Generating changelog from $LAST_SHA to $FULL_SHA..."
          CHANGELOG=$(git log --oneline "${LAST_SHA}..${FULL_SHA}" 2>/dev/null || echo "")
          if [ -n "$CHANGELOG" ]; then
            echo "Changelog:"
            echo "$CHANGELOG"
            # Escape for GitHub output
            CHANGELOG="${CHANGELOG//'%'/'%25'}"
            CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
            CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
          fi
        fi
        echo "changelog=$CHANGELOG" >> $GITHUB_OUTPUT
        
        # Install dependencies
        echo "Installing dependencies..."
        pnpm install --frozen-lockfile
        
        # Run build/package command if specified
        if [ -n "$PACKAGE_COMMAND" ]; then
          echo "Running package command: $PACKAGE_COMMAND"
          eval "$PACKAGE_COMMAND"
        fi
        
        # Create pack destination directory
        ORIGINAL_DIR="$GITHUB_WORKSPACE"
        FULL_PACK_DEST="$ORIGINAL_DIR/$PACK_DESTINATION"
        mkdir -p "$FULL_PACK_DEST"
        
        # Run pack command
        if [ -n "$PACK_COMMAND" ]; then
          echo "Running custom pack command: $PACK_COMMAND"
          eval "$PACK_COMMAND"
        else
          echo "Running default pack command..."
          pnpm pack --pack-destination "$FULL_PACK_DEST"
        fi
        
        # Find the packed file
        cd "$FULL_PACK_DEST"
        PACKED_FILE=$(ls -t *.tgz | head -1)
        
        if [ -z "$PACKED_FILE" ]; then
          echo "Error: No packed file found"
          exit 1
        fi
        
        echo "Packed file: $PACKED_FILE"
        
        # Rename with short SHA
        if [ -n "$PACKAGE_NAME" ]; then
          # Extract version from filename
          VERSION=$(echo "$PACKED_FILE" | sed -E 's/.*-([0-9]+\.[0-9]+\.[0-9]+)\.tgz$/\1/')
          FINAL_PACKAGE="${PACK_DESTINATION}/${PACKAGE_NAME//[@\/]/-}-${VERSION}-${SHORT_SHA}.tgz"
          
          # Rename the file
          NEW_NAME="${PACKAGE_NAME//[@\/]/-}-${VERSION}-${SHORT_SHA}.tgz"
          mv "$PACKED_FILE" "$NEW_NAME"
          echo "Renamed to: $NEW_NAME"
          
          # Save package file output
          echo "package-file=$FINAL_PACKAGE" >> $GITHUB_OUTPUT
        else
          FINAL_PACKAGE="${PACK_DESTINATION}/${PACKED_FILE}"
          echo "package-file=$FINAL_PACKAGE" >> $GITHUB_OUTPUT
        fi
        
        # Return to original directory
        cd "$ORIGINAL_DIR"
        
        # Update version file
        echo "Updating $FILE_PATH with SHA: $FULL_SHA"
        cat > "$FILE_PATH" << EOF
        # SHA of the last packed version of $PACKAGE_NAME
        $FULL_SHA
        EOF
        
        # Update package.json if package name is specified
        if [ -n "$PACKAGE_NAME" ] && [ -n "$FINAL_PACKAGE" ]; then
          echo "Updating package.json to reference $FINAL_PACKAGE"
          cat package.json | jq ".dependencies[\"$PACKAGE_NAME\"] = \"file:$FINAL_PACKAGE\"" > package.json.tmp
          mv package.json.tmp package.json
        fi
        
        # Clean up temp directory
        rm -rf "$TEMP_DIR"
        
        echo "Pack complete!"
name: 'Generate Update PR'
description: 'Generate a PR to update packed dependencies with commit log'
author: 'Your Organization'

inputs:
  target-sha:
    description: 'Target commit SHA or branch name. Leave blank for latest'
    required: false
    default: ''
  allow-rollback:
    description: 'Allow a commit older than the last merged SHA'
    required: false
    default: 'false'
  mode:
    description: 'PR mode (test or release)'
    required: false
    default: 'test'
  file-path:
    description: 'Path to version file'
    required: false
    default: '.ui-sha'
  repository:
    description: 'Source repository (owner/name)'
    required: true
  pack-destination:
    description: 'Directory for packed files'
    required: false
    default: './packs'
  pre-pack-commands:
    description: 'Commands to run before packing (e.g., svelte-kit sync)'
    required: false
    default: ''
  package-command:
    description: 'Command to build the package before packing'
    required: false
    default: ''
  remove-prepare-script:
    description: 'Remove prepare script from package.json'
    required: false
    default: 'true'
  ignore-scripts:
    description: 'Use --ignore-scripts when installing'
    required: false
    default: 'true'
  package-name:
    description: 'Name of the package being packed (for finding .tgz file)'
    required: false
    default: ''
  pr-title-template:
    description: 'Template for PR title'
    required: false
    default: '{mode} {repository}@{short_sha}'
  pr-body-template:
    description: 'Template for PR body'
    required: false
    default: |
      This PR uses a local `.tgz` package built from `{repository}@{resolved_sha}`.
      The `.tgz` was created with `pnpm pack` and installed directly. Use this pr to confirm the commit is functional.

      ### ðŸ§¾ Changes in [`{repository}`](https://github.com/{repository})
      **Commit range:** [`{last_sha}...{resolved_sha}`](https://github.com/{repository}/compare/{last_sha}...{resolved_sha})

      {commit_messages}
  labels:
    description: 'Labels to add to PR'
    required: false
    default: '{mode}-ui'
  draft:
    description: 'Create as draft PR (always-true, true, false)'
    required: false
    default: 'always-true'
  token:
    description: 'GitHub token'
    required: false
    default: ${{ github.token }}

outputs:
  pr-created:
    description: 'Whether a PR was created'
    value: ${{ steps.create-pr.outputs.pull-request-number != '' }}
  pr-number:
    description: 'PR number if created'
    value: ${{ steps.create-pr.outputs.pull-request-number }}
  pr-url:
    description: 'PR URL if created'
    value: ${{ steps.create-pr.outputs.pull-request-url }}
  resolved-sha:
    description: 'Resolved commit SHA'
    value: ${{ steps.validate-sha.outputs.resolved-sha }}
  short-sha:
    description: 'Short commit SHA'
    value: ${{ steps.validate-sha.outputs.short-sha }}
  last-sha:
    description: 'Last merged SHA'
    value: ${{ steps.validate-sha.outputs.last-sha }}

runs:
  using: 'composite'
  steps:
    - name: Validate and resolve SHA
      id: validate-sha
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        FILE_PATH="${{ inputs.file-path }}"
        REPO="${{ inputs.repository }}"
        TARGET_SHA="${{ inputs.target-sha }}"
        ALLOW_ROLLBACK="${{ inputs.allow-rollback }}"

        # Get last merged SHA from file
        LAST_SHA=""
        if [ -f "$FILE_PATH" ]; then
          LAST_SHA=$(head -n 1 "$FILE_PATH" | tr -d '[:space:]')
        fi
        echo "last-sha=$LAST_SHA" >> $GITHUB_OUTPUT

        # Resolve target SHA
        if [ -z "$TARGET_SHA" ]; then
          echo "Fetching latest commit from $REPO..."
          # Get the default branch first
          DEFAULT_BRANCH=$(gh api repos/$REPO --jq .default_branch)
          echo "Default branch: $DEFAULT_BRANCH"
          RESOLVED_SHA=$(gh api repos/$REPO/commits/$DEFAULT_BRANCH --jq .sha)
        else
          # Check if it's a branch name or SHA
          if [[ "$TARGET_SHA" =~ ^[0-9a-f]{7,40}$ ]]; then
            RESOLVED_SHA="$TARGET_SHA"
          else
            echo "Resolving branch $TARGET_SHA to SHA..."
            RESOLVED_SHA=$(gh api repos/$REPO/commits/$TARGET_SHA --jq .sha)
          fi
        fi

        echo "resolved-sha=$RESOLVED_SHA" >> $GITHUB_OUTPUT
        echo "short-sha=${RESOLVED_SHA:0:8}" >> $GITHUB_OUTPUT

        # Check if rollback without permission
        if [ -n "$LAST_SHA" ] && [ "$ALLOW_ROLLBACK" != "true" ]; then
          # Compare commit dates
          LAST_DATE=$(gh api repos/$REPO/commits/$LAST_SHA --jq .commit.committer.date)
          NEW_DATE=$(gh api repos/$REPO/commits/$RESOLVED_SHA --jq .commit.committer.date)

          if [[ "$NEW_DATE" < "$LAST_DATE" ]]; then
            echo "Error: Target commit is older than last merged commit. Set allow-rollback=true to proceed."
            exit 1
          fi
        fi

        # Check if same as last SHA
        if [ "$RESOLVED_SHA" = "$LAST_SHA" ]; then
          echo "Target SHA is same as current. No update needed."
          echo "needs-update=false" >> $GITHUB_OUTPUT
        else
          echo "needs-update=true" >> $GITHUB_OUTPUT
        fi

    - name: Build commit log
      if: steps.validate-sha.outputs.needs-update == 'true'
      id: commit-log
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        REPO="${{ inputs.repository }}"
        LAST_SHA="${{ steps.validate-sha.outputs.last-sha }}"
        NEW_SHA="${{ steps.validate-sha.outputs.resolved-sha }}"

        if [ -z "$LAST_SHA" ]; then
          # First time setup, just show new commit
          COMMITS=$(gh api repos/$REPO/commits/$NEW_SHA --jq '"- [" + .sha[0:8] + "](" + .html_url + ") " + .commit.message')
        else
          # Get commit range
          COMMITS=$(gh api "repos/$REPO/compare/${LAST_SHA}...${NEW_SHA}" \
            --jq '.commits[] | "- [" + .sha[0:8] + "](" + .html_url + ") " + (.commit.message | split("\n")[0])')
        fi

        echo "commit-messages<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Update SHA file
      if: steps.validate-sha.outputs.needs-update == 'true'
      shell: bash
      run: |
        echo "${{ steps.validate-sha.outputs.resolved-sha }}" > ${{ inputs.file-path }}

    - name: Download and pack dependency
      if: steps.validate-sha.outputs.needs-update == 'true'
      shell: bash
      run: |
        REPO="${{ inputs.repository }}"
        SHA="${{ steps.validate-sha.outputs.resolved-sha }}"
        PACK_DIR="${{ inputs.pack-destination }}"
        PACKAGE_NAME="${{ inputs.package-name }}"

        # Reset packs directory
        rm -rf "$PACK_DIR"
        mkdir -p "$PACK_DIR"

        # Download source as tarball
        echo "Downloading $REPO@$SHA..."
        curl -L "https://github.com/$REPO/archive/$SHA.tar.gz" -o source.tar.gz
        tar -xzf source.tar.gz

        # Find extracted directory (GitHub creates it as repo-name-sha)
        REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)
        SOURCE_DIR="${REPO_NAME}-${SHA}"

        # Remove dependency from parent package.json if package name is provided
        if [ -n "$PACKAGE_NAME" ] && [ -f "package.json" ]; then
          echo "Removing $PACKAGE_NAME from parent package.json..."
          cat package.json | jq "del(.dependencies[\"$PACKAGE_NAME\"])" > package.json.tmp
          mv package.json.tmp package.json
        fi

        cd "$SOURCE_DIR"

        # Remove prepare script if requested
        if [ "${{ inputs.remove-prepare-script }}" = "true" ] && [ -f "package.json" ]; then
          echo "Removing prepare script..."
          cat package.json | jq 'del(.scripts.prepare)' > package.json.tmp
          mv package.json.tmp package.json
        fi

        # Install dependencies
        INSTALL_FLAGS=""
        if [ "${{ inputs.ignore-scripts }}" = "true" ]; then
          INSTALL_FLAGS="--ignore-scripts"
        fi
        echo "Installing dependencies..."
        pnpm install $INSTALL_FLAGS

        # Run pre-pack commands if provided
        if [ -n "${{ inputs.pre-pack-commands }}" ]; then
          echo "Running pre-pack commands..."
          eval "${{ inputs.pre-pack-commands }}"
        fi

        # Run package command if provided
        if [ -n "${{ inputs.package-command }}" ]; then
          echo "Running package command..."
          eval "${{ inputs.package-command }}"
        fi

        # Pack the package
        echo "Packing..."
        pnpm pack --pack-destination "../$PACK_DIR"

        cd ..

        # Rename packed file to include SHA
        if [ -n "$PACKAGE_NAME" ]; then
          # Find the packed file with the package name pattern
          PACKED_FILE=$(ls "$PACK_DIR/${PACKAGE_NAME}"*.tgz 2>/dev/null | head -n 1)
          if [ -n "$PACKED_FILE" ]; then
            # Extract just the filename
            FILENAME=$(basename "$PACKED_FILE")
            # Remove version and .tgz, then add SHA
            BASE_NAME=$(echo "$FILENAME" | sed 's/-[0-9].*\.tgz$//')
            mv "$PACKED_FILE" "$PACK_DIR/${BASE_NAME}-${SHA}.tgz"
            FINAL_PACKAGE="$PACK_DIR/${BASE_NAME}-${SHA}.tgz"
          fi
        else
          # Generic rename for any .tgz file
          PACKED_FILE=$(ls "$PACK_DIR"/*.tgz 2>/dev/null | head -n 1)
          if [ -n "$PACKED_FILE" ]; then
            FILENAME=$(basename "$PACKED_FILE" .tgz)
            mv "$PACKED_FILE" "$PACK_DIR/${FILENAME}-${SHA}.tgz"
            FINAL_PACKAGE="$PACK_DIR/${FILENAME}-${SHA}.tgz"
          fi
        fi

        # Clean up source directory
        rm -rf "$SOURCE_DIR" source.tar.gz

        # Install the packed dependency
        if [ -n "$FINAL_PACKAGE" ]; then
          echo "Installing packed dependency: $FINAL_PACKAGE"
          pnpm add "$FINAL_PACKAGE"
          pnpm install
        else
          echo "Warning: No packed file found"
        fi

    - name: Prepare PR details
      if: steps.validate-sha.outputs.needs-update == 'true'
      id: prepare-pr
      shell: bash
      run: |
        # Prepare branch name
        BRANCH_NAME="${{ inputs.mode }}-ui-${{ steps.validate-sha.outputs.short-sha }}"
        echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

        # Prepare title
        TITLE="${{ inputs.pr-title-template }}"
        TITLE="${TITLE//\{mode\}/${{ inputs.mode }}}"
        TITLE="${TITLE//\{repository\}/${{ inputs.repository }}}"
        TITLE="${TITLE//\{short_sha\}/${{ steps.validate-sha.outputs.short-sha }}}"
        echo "title=$TITLE" >> $GITHUB_OUTPUT

        # Prepare labels
        LABELS="${{ inputs.labels }}"
        LABELS="${LABELS//\{mode\}/${{ inputs.mode }}}"
        echo "labels=$LABELS" >> $GITHUB_OUTPUT

        # Prepare body
        BODY="${{ inputs.pr-body-template }}"
        BODY="${BODY//\{repository\}/${{ inputs.repository }}}"
        BODY="${BODY//\{resolved_sha\}/${{ steps.validate-sha.outputs.resolved-sha }}}"
        BODY="${BODY//\{pack_command\}/pnpm pack}"
        BODY="${BODY//\{last_sha\}/${{ steps.validate-sha.outputs.last-sha }}}"

        # Handle commit messages separately due to multiline nature
        COMMIT_MESSAGES="${{ steps.commit-log.outputs.commit-messages }}"
        BODY="${BODY//\{commit_messages\}/$COMMIT_MESSAGES}"

        echo "body<<EOF" >> $GITHUB_OUTPUT
        echo "$BODY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create Pull Request
      if: steps.validate-sha.outputs.needs-update == 'true'
      id: create-pr
      uses: peter-evans/create-pull-request@v7
      with:
        token: ${{ inputs.token }}
        reviewers: ${{ github.actor }}
        committer: ${{ github.actor }} <${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com>
        author: ${{ github.actor }} <${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com>
        branch: ${{ steps.prepare-pr.outputs.branch }}
        commit-message: 'chore: set ${{ inputs.repository }}@${{ steps.validate-sha.outputs.resolved-sha }}'
        title: ${{ steps.prepare-pr.outputs.title }}
        add-paths: 'package.json, pnpm-lock.yaml, ${{ inputs.pack-destination }}, ${{ inputs.file-path }}'
        labels: ${{ steps.prepare-pr.outputs.labels }}
        draft: ${{ inputs.draft }}
        body: ${{ steps.prepare-pr.outputs.body }}

name: 'Move Pack'
description: 'Move packed files from source to destination with optional renaming'

inputs:
  source-path:
    description: 'Path to source directory containing packed files'
    required: false
    default: 'source'
  pack-destination:
    description: 'Destination directory for packed files'
    required: false
    default: './packs'
  package-name:
    description: 'Package name for renaming (single mode only)'
    required: false
  sha:
    description: 'SHA for file naming'
    required: false
  source-pattern:
    description: 'Pattern to find packed files (single mode: e.g., *.tgz)'
    required: false
    default: '*.tgz'
  packages:
    description: 'Multiline list of packages to move in format "name:pattern" (batch mode). Example: "registry:*registry*.tgz"'
    required: false

outputs:
  package-file:
    description: 'Path to moved package'
    value: ${{ steps.move.outputs.package-file }}

runs:
  using: composite
  steps:
    - name: Move packed files
      id: move
      shell: bash
      env:
        INPUT_SOURCE_PATH: ${{ inputs.source-path }}
        INPUT_PACK_DEST: ${{ inputs.pack-destination }}
        INPUT_PACKAGE_NAME: ${{ inputs.package-name }}
        INPUT_SHA: ${{ inputs.sha }}
        INPUT_SOURCE_PATTERN: ${{ inputs.source-pattern }}
        INPUT_PACKAGES: ${{ inputs.packages }}
      run: |
        SOURCE_PATH="$INPUT_SOURCE_PATH"
        ROOT_PACK_DEST="$INPUT_PACK_DEST"
        SHA="$INPUT_SHA"
        ROOT_DIR=$(pwd)

        # Create root pack destination
        mkdir -p "$ROOT_PACK_DEST"

        # Function to move a single package
        move_package() {
          local PACKAGE_NAME="$1"
          local PATTERN="$2"

          # Clean up old versions of this specific package if package name provided
          if [ -n "$PACKAGE_NAME" ]; then
            CLEAN_NAME="${PACKAGE_NAME//[@\/]/-}"
            CLEAN_NAME="${CLEAN_NAME#-}"
            echo "Cleaning up old versions of $CLEAN_NAME..." >&2
            rm -f "$ROOT_PACK_DEST/$CLEAN_NAME"-*.tgz 2>/dev/null || true
          fi

          cd "$SOURCE_PATH"

          # Find the packed file
          PACKED_FILE=$(find . -name "$PATTERN" -type f | head -1)

          if [ -z "$PACKED_FILE" ]; then
            echo "Error: No packed file found matching pattern: $PATTERN" >&2
            return 1
          fi

          echo "Found packed file: $PACKED_FILE" >&2

          # Get the base filename
          PACKED_FILENAME=$(basename "$PACKED_FILE")

          # Construct new filename with SHA
          if [ -n "$SHA" ]; then
            if [ -n "$PACKAGE_NAME" ]; then
              # Use provided package name
              CLEAN_NAME="${PACKAGE_NAME//[@\/]/-}"
              CLEAN_NAME="${CLEAN_NAME#-}"
              NEW_NAME="${CLEAN_NAME}-${SHA:0:8}.tgz"
            else
              # Extract package name from filename and add SHA
              BASE_NAME="${PACKED_FILENAME%.tgz}"
              NEW_NAME="${BASE_NAME}-${SHA:0:8}.tgz"
            fi
          else
            NEW_NAME="$PACKED_FILENAME"
          fi

          # Move the packed file to root repo's packs directory
          FINAL_PATH="$ROOT_DIR/$ROOT_PACK_DEST/$NEW_NAME"
          mv "$PACKED_FILE" "$FINAL_PATH"

          echo "Moved to: $FINAL_PATH" >&2

          # Return to root directory
          cd "$ROOT_DIR"

          echo "$ROOT_PACK_DEST/$NEW_NAME"
        }

        # Check if batch mode (packages input provided)
        if [ -n "$INPUT_PACKAGES" ]; then
          echo "Running in batch mode..." >&2
          PACKAGE_FILES=()

          # Process each package line
          while IFS= read -r line; do
            # Skip empty lines
            [ -z "$line" ] && continue

            # Parse name:pattern format
            if [[ "$line" =~ ^([^:]+):(.+)$ ]]; then
              PKG_NAME="${BASH_REMATCH[1]}"
              PKG_PATTERN="${BASH_REMATCH[2]}"

              echo "Processing package: $PKG_NAME with pattern: $PKG_PATTERN" >&2
              MOVED_FILE=$(move_package "$PKG_NAME" "$PKG_PATTERN")
              PACKAGE_FILES+=("$MOVED_FILE")
            else
              echo "Warning: Skipping invalid line format (expected 'name:pattern'): $line" >&2
            fi
          done <<< "$INPUT_PACKAGES"

          # Output first package file for backwards compatibility
          if [ ${#PACKAGE_FILES[@]} -gt 0 ]; then
            echo "package-file=${PACKAGE_FILES[0]}" >> $GITHUB_OUTPUT
          fi

        else
          # Single mode (backwards compatible)
          echo "Running in single mode..." >&2
          PACKAGE_NAME="$INPUT_PACKAGE_NAME"
          PATTERN="$INPUT_SOURCE_PATTERN"

          MOVED_FILE=$(move_package "$PACKAGE_NAME" "$PATTERN")
          echo "package-file=$MOVED_FILE" >> $GITHUB_OUTPUT
        fi

name: 'Build and Pack'
description: 'Build and pack a dependency with custom commands'

inputs:
  source-path:
    description: 'Path to source code'
    required: false
    default: 'source'
  pack-destination:
    description: 'Directory for packed files'
    required: false
    default: './packs'
  package-command:
    description: 'Build command before packing'
    required: false
  pack-command:
    description: 'Custom pack command'
    required: false
  package-name:
    description: 'Package name for renaming'
    required: false
  sha:
    description: 'SHA for file naming'
    required: false
  remove-prepare:
    description: 'Remove prepare script'
    required: false
    default: 'true'

outputs:
  package-file:
    description: 'Path to created package'
    value: ${{ steps.pack.outputs.package-file }}

runs:
  using: composite
  steps:
    - name: Prepare source
      shell: bash
      run: |
        cd "${{ inputs.source-path }}"

        # Remove prepare script if requested
        if [ "${{ inputs.remove-prepare }}" = "true" ] && [ -f "package.json" ]; then
          echo "Removing prepare script..."
          cat package.json | jq 'del(.scripts.prepare)' > package.json.tmp
          mv package.json.tmp package.json
        fi

    - name: Install dependencies
      shell: bash
      run: |
        cd "${{ inputs.source-path }}"
        pnpm install --frozen-lockfile --ignore-scripts

    - name: Build package
      if: inputs.package-command != ''
      shell: bash
      run: |
        cd "${{ inputs.source-path }}"
        echo "Running: ${{ inputs.package-command }}"
        eval "${{ inputs.package-command }}"

    - name: Pack dependency
      id: pack
      shell: bash
      run: |
        SOURCE_PATH="${{ inputs.source-path }}"
        ROOT_PACK_DEST="${{ inputs.pack-destination }}"
        PACKAGE_NAME="${{ inputs.package-name }}"
        SHA="${{ inputs.sha }}"

        # Store current directory
        ROOT_DIR=$(pwd)

        # Create root pack destination
        mkdir -p "$ROOT_PACK_DEST"
        rm -rf "$ROOT_PACK_DEST/*"

        cd "$SOURCE_PATH"

        # Run pack command (it will use its own pack destination)
        if [ -n "${{ inputs.pack-command }}" ]; then
          echo "Running: ${{ inputs.pack-command }}"
          eval "${{ inputs.pack-command }}"

          # The pack command should have created a .tgz file
          # Find it (could be in current dir or a subdirectory)
          PACKED_FILE=$(find . -name "*.tgz" -type f -mmin -1 | head -1)
        else
          # Default: use pnpm pack to current directory
          pnpm pack
          PACKED_FILE=$(ls -t *.tgz | head -1)
        fi

        if [ -z "$PACKED_FILE" ]; then
          echo "Error: No pack file created"
          exit 1
        fi

        echo "Found packed file: $PACKED_FILE"

        # Get the base filename
        PACKED_FILENAME=$(basename "$PACKED_FILE")

        # Construct new filename with SHA
        if [ -n "$SHA" ]; then
          if [ -n "$PACKAGE_NAME" ]; then
            # Use provided package name
            CLEAN_NAME="${PACKAGE_NAME//[@\/]/-}"
            CLEAN_NAME="${CLEAN_NAME#-}"
            NEW_NAME="${CLEAN_NAME}-${SHA:0:8}.tgz"
          else
            # Extract package name from filename and add SHA
            BASE_NAME="${PACKED_FILENAME%.tgz}"
            NEW_NAME="${BASE_NAME}-${SHA:0:8}.tgz"
          fi
        else
          NEW_NAME="$PACKED_FILENAME"
        fi

        # Move the packed file to root repo's packs directory
        FINAL_PATH="$ROOT_DIR/$ROOT_PACK_DEST/$NEW_NAME"
        mv "$PACKED_FILE" "$FINAL_PATH"

        echo "Moved to: $FINAL_PATH"
        echo "package-file=$ROOT_PACK_DEST/$NEW_NAME" >> $GITHUB_OUTPUT
